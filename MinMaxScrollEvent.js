// Generated by CoffeeScript 2.1.1
(function() {
  // A generic scroll end-start  listener. will listen and distpach events when its (one and only) child reaches the maximum (or minimum) desired scrolling position
  var Component, DEFAULT_PROPS, MinMaxEvent,
    boundMethodCheck = function(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new Error('Bound instance method accessed before binding'); } };

  ({Component} = require('preact'));

  DEFAULT_PROPS = {
    offsetMaxBeta: 100, //when scroll reaches % of scrollable element from end [---->|..(100)%..]
    offsetMinBeta: 100, //when scroll reaches % of scrollable element from start [..(100)%..|<----]
    offsetMax: 0, //when scroll reaches px of scrollable element from end [..(X)px..|<----]
    offsetMin: 0, //when scroll reaches px of scrollable element from start [---->|..(X)px..]
    vert: true, //vertical of horizontal scroll?
    onMaxReached: null, //when scroll reaches bottom/right event
    onMinReached: null //when scroll reaches top/left event
  };

  MinMaxEvent = class MinMaxEvent extends Component {
    constructor(opt) {
      super();
      this.onScroll = this.onScroll.bind(this);
      this.state = {
        min: false,
        max: false
      };
    }

    check() {
      var base, base1, base2, base3, max, min;
      if (this.props.vert) {
        max = this.base.scrollHeight - this.base.clientHeight - (this.props.offsetMax || this.base.clientHeight * this.props.offsetMaxBeta / 100);
        min = this.base.clientHeight * (this.props.offsetMin || this.props.offsetMinBeta / 100);
        if (this.base.scrollTop >= max && !this.state.max) {
          this.state.max = true;
          return typeof (base = this.props).onMaxReached === "function" ? base.onMaxReached(this.base) : void 0;
        } else if (this.base.scrollTop <= min && !this.state.min) {
          this.state.min = true;
          return typeof (base1 = this.props).onMinReached === "function" ? base1.onMinReached(this.base) : void 0;
        } else {
          if (this.base.scrollTop < max) {
            this.state.max = false;
          }
          if (this.base.scrollTop > min) {
            return this.state.min = false;
          }
        }
      } else {
        max = this.base.scrollWidth - this.base.clientWidth - (this.props.offsetMax || this.base.clientWidth * this.props.offsetMaxBeta / 100);
        min = this.base.clientWidth * (this.props.offsetMin || this.props.offsetMinBeta / 100);
        if (this.base.scrollLeft >= max && !this.state.max) {
          this.state.max = true;
          return typeof (base2 = this.props).onMaxReached === "function" ? base2.onMaxReached(this.base) : void 0;
        } else if (this.base.scrollLeft <= min && !this.state.min) {
          this.state.min = true;
          return typeof (base3 = this.props).onMinReached === "function" ? base3.onMinReached(this.base) : void 0;
        } else {
          if (this.base.scrollLeft < max) {
            this.state.max = false;
          }
          if (this.base.scrollTop > min) {
            return this.state.min = false;
          }
        }
      }
    }

    onScroll() {
      boundMethodCheck(this, MinMaxEvent);
      return this.check();
    }

    componentDidMount() {
      this.base.addEventListener('scroll', this.onScroll);
      return this.check();
    }

    componentWillUnmount() {
      return this.base.removeEventListener('scroll', this.onScroll);
    }

    componentDidUpdate() {
      this.base.removeEventListener('scroll', this.onScroll);
      this.base.addEventListener('scroll', this.onScroll);
      return this.check();
    }

    // console.log 'litener update'
    render() {
      return this.props.children[0];
    }

  };

  MinMaxEvent.defaultProps = DEFAULT_PROPS;

  module.exports = MinMaxEvent;

}).call(this);
